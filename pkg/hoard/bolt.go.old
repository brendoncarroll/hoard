package hoard

import (
	"context"
	"encoding/binary"

	"github.com/brendoncarroll/go-state/cadata"
	"github.com/brendoncarroll/go-state/cells"
	bolt "go.etcd.io/bbolt"
)

type BoltBackend struct {
	db *bolt.DB
}

func NewBoltBackend(db *bolt.DB) *BoltBackend {
	return &BoltBackend{
		db: db,
	}
}

func (b *BoltBackend) Do(ctx context.Context, mutable bool, fn func(be Backend) error) error {
	return b.db.Batch(func(tx *bolt.Tx) error {
		return fn(txWrapper{tx})
	})
}

type txWrapper struct {
	tx *bolt.Tx
}

func (w txWrapper) GetCell(x uint64) cells.Cell {
	path := [][]byte{
		[]byte("cells"),
		putUint64(x),
	}
	return boltCell{tx: w.tx, path: path}
}

func (w *txWrapper) GetStore(x uint64) cells.Cell {

}

type Backend interface {
	GetCell(uint64) cells.Cell
	GetStore(uint64) cadata.Store
}

type boltCell struct {
	tx   *bolt.Tx
	path [][]byte
}

func (c boltCell) CAS(ctx context.Context, actual, prev, next []byte) (bool, int, error) {

}

func (c boltCell) Get(ctx context.Context, buf []byte) (int, error) {

}

func (b boltCell) MaxSize() int {
	return 1 << 16
}

func putUint64(x uint64) []byte {
	buf := [8]byte{}
	binary.BigEndian.PutUint64(buf[:], x)
	return buf[:]
}
